#!/usr/bin/env just --justfile

set dotenv-load
set positional-arguments 

@_default:
  just --justfile {{justfile()}} --list --list-heading '' --list-prefix 'dotenv '

# Create .env .env.example and add .env to gitignore
create:
  #!/bin/bash

  [ ! -z $PRJ_ROOT ] && just --justfile {{justfile_directory()}}/justfile project_root

  [ ! -f $PRJ_ROOT/.env ] && touch $PRJ_ROOT/.env

  # TODO: add copying env var keys without values to .env.example list or do it on git secrets sync. 
  # [ ! -f $PRJ_ROOT/.env.example ] && touch $PRJ_ROOT/.env.example
  [ ! -f $PRJ_ROOT/.gitignore ] && touch $PRJ_ROOT/.gitignore
  if ! grep -q ".env" .gitignore; then
    echo -e ".env" >> .gitignore
    echo -e "!.env.example" >> .gitignore
  fi

# Update .env variable | Usage: update_env key value group(optional) file(optional)
update *args='':
  #!/usr/bin/bash
  [ ! -f "${PRJ_ROOT}/.env" ] && just --justfile {{justfile_directory()}}/dotenv create
  key="$1"
  value="\"$2\""
  group="${3:-else}"
  file="${4:-${PRJ_ROOT}/.env}"

  if grep -q "^$key=" "$file"; then
      sed -i "s/^$key=.*/$key=$value/" "$file"
  elif grep -q "^# $group" "$file"; then
      sed -i "/^# $group/a\\
  $key=$value" "$file"
  else
      echo -e "\n# $group\n$key=$value" >> "$file"
  fi
  just --justfile {{justfile_directory()}}/dotenv load_with_direnv

# Load dotenv with direnv
load_with_direnv:
  #!/usr/bin/bash
  if [ ! -f $PRJ_ROOT/.envrc ]; then
    echo "[ -f $PRJ_ROOT/.env ] && dotenv" >> $PRJ_ROOT/.envrc
  fi

  direnv allow

# Create dotenv-vault and login to dotenv server
vault_init:
  npx dotenv-vault@latest new
  npx dotenv-vault@latest login

# push env to dotenv server
vault_push:
  npx dotenv-vault@latest push

# pull env from dotenv server
vault_pull:
  npx dotenv-vault@latest pull

# Encrypt dotenv with gpg key ( .env file and git gpg uses as default)
encrypt:
  #!/bin/bash

  FILE="${1:-.env}"
  GITKEY=$(git config --get user.signingkey)
  KEY="${2:-$GITKEY}"

  if [[ -z "$KEY" ]]; then
      echo "No GPG key. Set correct custom GPG key or set Git GPG 'git config --global user.signingkey YOURKEYID'."
      exit 1
  fi
  gpg --encrypt --recipient "$KEY" "$FILE"

# Decrypt dotenv with gpg key 
decrypt:
  #!/bin/bash

  FILE="${1:-.env.gpg}"
  GITKEY=$(git config --get user.signingkey)
  KEY="${2:-$GITKEY}"

  if [[ -z "$KEY" ]]; then
    echo "No GPG key. Set correct custom GPG key or set Git GPG 'git config --global user.signingkey YOURKEYID'."
    exit 1
  fi
  gpg --decrypt --output "${PRJ_ROOT}/.env" "$FILE"

# Push env vars to github repo secrets
_sync_to_gh_secrets:
  #!/bin/bash
  direnv allow
  echo $repo

  while IFS= read -r line
  do
    if [[ "$line" != *"="* ]]; then
      continue
    fi
    IFS='=' read -ra PARTS <<< "$line"
    echo ${PARTS[1]} | gh secret set ${PARTS[0]} --repo=$REPO --body=-
  done < "${PRJ_ROOT}/.env"

# Remove env vars to github repo secrets
_rm_from_gh_secrets:
  #!/bin/bash
  direnv allow
  echo $repo

  while IFS= read -r line
  do
    if [[ "$line" != *"="* ]]; then
      continue
    fi
    IFS='=' read -ra PARTS <<< "$line"
    echo ${PARTS[1]} | gh secret delete ${PARTS[0]} --repo=$REPO
  done < "${PRJ_ROOT}/.env"

# dotenv.example
create_example:
  #!/bin/bash

  input="${PRJ_ROOT}/.env"
  output="${PRJ_ROOT}/.env.example"
  placeholder="YOUR_VALUE_HERE"

  [ ! -f "$input" ] && echo "File $input does not exist." && exit 1

  # Create or clear the output file
  > $output

  while IFS= read -r line; do
    # Check if the line contains an equals sign
    if [[ $line == *"="* ]]; then
      # Split the line into name and value
      name="${line%%=*}"
      # Write the name and placeholder to the output file
      echo "$name=$placeholder" >> $output
    else
      # Write the line to the output file as is
      echo "$line" >> $output
    fi
  done < "$input"
  echo "File $output has been created."
